#!/usr/bin/env python
"""split_trees

Usage: split_trees /some/path/vXX /some/other/path/vXX

A short script to split the systematic trees off into their own files, while
merging files from separate jobs.

This should help with processing time, as each file that is run over is
smaller, and thus less data has to be transferred.

I.e. contents before:

    file0:
        makeNtuple/TTbarHTauTau
        makeNtupleJESUp/TTbarHTauTau_JESUp
        makeNtupleJESDown/TTbarHTauTau_JESDown

    file1:
        makeNtuple/TTbarHTauTau
        makeNtupleJESUp/TTbarHTauTau_JESUp
        makeNtupleJESDown/TTbarHTauTau_JESDown

    ...

contents after:

    file0:
        makeNtuple/TTbarHTauTau

    file1:
        makeNtupleJESUp/TTbarHTauTau_JESUp

    file2:
        makeNtupleJESDown/TTbarHTauTau_JESDown
"""

import os
import ROOT as r
import sys

from glob import glob

r.gROOT.SetBatch()

try:
    inpath = sys.argv[1]
    outpath = sys.argv[2]
except:
    sys.stderr.write("usage: split_trees input_dir output_dir\n")
    sys.exit(1)

if outpath.endswith('/'):
    outpath = outpath[:-1]
if not inpath.endswith('/'):
    inpath += '/'

datasets = filter(os.path.isdir, glob(os.path.join(sys.argv[1], '*', '*', '*')))
for set in datasets:
    files = glob(os.path.join(set, '*'))
    if len(files) == 0:
        continue

    trees = []
    snoop = r.TFile(files[0])
    for k in snoop.GetListOfKeys():
        for kk in k.ReadObj().GetListOfKeys():
            if kk.GetName() == 'EventsRead':
                continue
            trees.append((k.GetName(), kk.GetName()))

    subpath = set.replace(inpath, '')
    print "Processing", subpath

    for (dir, tree) in trees:
        chain = r.TChain(os.path.join(dir, tree))
        print "Using tree", os.path.join(dir, tree)
        for f in files:
            chain.Add(f)

        suffix = dir.replace('makeNtuple', '')
        newpath = os.path.join(outpath + suffix, subpath)
        print "Writing to", newpath
        if not os.path.exists(newpath):
            os.makedirs(newpath)
        outfile = r.TFile(os.path.join(newpath, 'NUT.root'), 'RECREATE')
        outfile.mkdir(dir).cd()
        clone = chain.CloneTree()
        clone.Write()
        outfile.Close()
        print "Done!"
